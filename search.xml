<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS应用内购买IAP]]></title>
    <url>%2F2017%2F06%2F13%2FiOS%E5%BA%94%E7%94%A8%E5%86%85%E8%B4%AD%E4%B9%B0IAP%2F</url>
    <content type="text"><![CDATA[iOS应用内购买IAP 最近苹果针对iOS应用软件开发者的指引政策进行了修改，，第一次明确指出用户支付小费或者打赏，必须通过苹果的支付渠道，也就是不能绕开苹果iOS管理机制。微信在iOS版本取消了打赏功能，知乎则是向苹果低了头…苹果在相关文档中提到，如果开发者想在iOS软件提供下述功能（比如用户订阅、游戏内虚拟货币、获取高端会员内容、或者提供完整的功能版本等），则开发者必须使用软件内购买。 本文主要以自动订阅类型产品为主，其他类型产品为辅 准备In-App Purchase， 简称IAP，允许在iOS app与macOS app中出售商品。 新建一个app，然后添加App 内购买项目，主要分四种内购买项目类型。 消耗品（Consumable products）：会越用越少的，比如游戏内金币等。 不可消耗品（Non-consumable products）：比如游戏中跑车，简单来说就是一次购买，终身可用（用户可随时从App Store restore） 自动更新订阅品（Auto-renewable subscriptions）：和不可消耗品的不同点是有失效时间。比如一整年的付费周刊。在这种模式下，开发者定期投递内容，用户在订阅期内随时可以访问这些内容。订阅快要过期时，系统将自动更新订阅。 非自动更新订阅品（Non-renewable subscriptions）：一般使用场景是从用户从IAP购买后，购买信息存放在自己的开发者服务器上。失效日期/可用是由开发者服务器自行控制的，而非由App Store控制，这一点与自动更新订阅品有差异。 添加APP内购买项目 设置税务和银行卡信息 添加沙盒测试账号 使用StoreKit API 获取产品列表，展现的产品可以后台配置(Consumable可消耗商品举例) 12345678910111213141516171819202122232425262728293031323334// MARK: - FETCH AVAILABLE IAP PRODUCTS func fetchAvailableProducts() &#123; Toast(text: "fetching available products").show() // Put here your IAP Products ID's let productIdentifiers = NSSet(objects: COINS_PRODUCT_ID,PREMIUM_PRODUCT_ID ) productsRequest = SKProductsRequest(productIdentifiers: productIdentifiers as! Set&lt;String&gt;) productsRequest.delegate = self productsRequest.start() &#125; // MARK: - REQUEST IAP PRODUCTS func productsRequest (_ request:SKProductsRequest, didReceive response:SKProductsResponse) &#123; if (response.products.count &gt; 0) &#123; Toast(text: "fetch \(response.products.count) product success").show() iapProducts = response.products // 1st IAP Product (Consumable) ------------------------------------ let firstProduct = response.products[0] as SKProduct // Get its price from iTunes Connect let numberFormatter = NumberFormatter() numberFormatter.formatterBehavior = .behavior10_4 numberFormatter.numberStyle = .currency numberFormatter.locale = firstProduct.priceLocale let price1Str = numberFormatter.string(from: firstProduct.price) // Show its description consumableLabel.text = firstProduct.localizedDescription + "\nfor just \(price1Str!)" &#125; &#125; 购买产品，首先检查设备是否支持内购买，然后将交易加入支付队列 123456789101112131415161718192021// MARK: - MAKE PURCHASE OF A PRODUCT func canMakePurchases() -&gt; Bool &#123; return SKPaymentQueue.canMakePayments() &#125; func purchaseMyProduct(product: SKProduct) &#123; if self.canMakePurchases() &#123; Toast(text: "begin purchase for \(product.localizedTitle)").show() let payment = SKPayment(product: product) SKPaymentQueue.default().add(self) SKPaymentQueue.default().add(payment) print("PRODUCT TO PURCHASE: \(product.productIdentifier)") productID = product.productIdentifier // IAP Purchases dsabled on the Device &#125; else &#123; UIAlertView(title: "IAP Tutorial", message: "Purchases are disabled in your device!", delegate: nil, cancelButtonTitle: "OK").show() &#125; &#125; 处理支付结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// MARK:- IAP PAYMENT QUEUE func paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]) &#123; for transaction:AnyObject in transactions &#123; if let trans = transaction as? SKPaymentTransaction &#123; let msg = self.descFromTransactionState(trans.transactionState); if(msg != nil)&#123; Toast(text: msg).show() &#125; switch trans.transactionState &#123; case .purchased: SKPaymentQueue.default().finishTransaction(transaction as! SKPaymentTransaction) guard let receiptUrl = Bundle.main.appStoreReceiptURL else &#123; SKPaymentQueue.default() return &#125; let receipt = try? Data.init(contentsOf: receiptUrl) //自动订阅类型需要验证receipt 发到 apple guard let receiptBase64String = receipt?.base64EncodedString() else &#123; return &#125; let dict = ["receipt-data": receiptBase64String] let url:URL? = URL(string:"https://sandbox.itunes.apple.com/verifyReceipt") var request = URLRequest.init(url: url!) request.httpMethod = "POST" let data = try? JSONSerialization.data(withJSONObject: dict, options: JSONSerialization.WritingOptions.prettyPrinted) request.httpBody = data URLSession.shared.dataTask(with: request, completionHandler: &#123; (data, response, error) in if(data != nil)&#123; let JSONObj = try? JSONSerialization.jsonObject(with: data!, options: .allowFragments) let str = String(data: data!, encoding: .utf8) print(str!) print(JSONObj!) &#125; &#125;).resume() break case .failed: SKPaymentQueue.default().finishTransaction(transaction as! SKPaymentTransaction) break case .restored: SKPaymentQueue.default().finishTransaction(transaction as! SKPaymentTransaction) break default: break &#125;&#125;&#125; &#125; 使用SwiftyStoreKit库简化调用API SwiftyStoreKit对StoreKit的api进行封装，调用起来更加方便。具体api请参考SwiftyStoreKit Github 需要注意的购买商品时api 区分原子性和非原子性；原子性是购买成功后，购买的内容能立即传递给用户界面，而非原子性是指购买的内容需要从服务器下载，需要下载完毕，才调用完成交易的api来结束交易 12345678910111213141516171819202122SwiftyStoreKit.purchaseProduct("com.musevisions.SwiftyStoreKit.Purchase1", quantity: 1, atomically: false) &#123; result in switch result &#123; case .success(let product): // fetch content from your server, then: if product.needsFinishTransaction &#123; SwiftyStoreKit.finishTransaction(product.transaction) &#125; print("Purchase Success: \(product.productId)") case .error(let error): switch error.code &#123; case .unknown: print("Unknown error. Please contact support") case .clientInvalid: print("Not allowed to make the payment") case .paymentCancelled: break case .paymentInvalid: print("The purchase identifier was invalid") case .paymentNotAllowed: print("The device is not allowed to make the payment") case .storeProductNotAvailable: print("The product is not available in the current storefront") case .cloudServicePermissionDenied: print("Access to cloud service information is not allowed") case .cloudServiceNetworkConnectionFailed: print("Could not connect to the network") case .cloudServiceRevoked: print("User has revoked permission to use this cloud service") &#125; &#125;&#125; 自动订阅类型总结 注册在AppDelegate中didFinishLaunchingWithOptions中，注册交易观察者，这样app就可以收到支付队列的通知（自动续订时会被调用） 沙盒测试周期会被加速，订阅周期为1周，在沙盒环境下只需3分钟，1个月只需5分钟…苹果考虑的挺周到的 一个沙盒测试账号一天只能被更新订阅5次，测试自动订阅时尤其注意，可以使用多个测试账号（当时我以为没能自动订阅呢） 客户端先将receipt发给服务端，服务端去验证receipt 有时返回 210007 状态码，意味着这个receipt是测试环境的，但发送到了正式环境https://buy.itunes.apple.com/verifyReceip。而且审核时，苹果人员也是用沙盒环境测试，如何切换正式和测试环境呢？解决方案：服务端先走正式环境，如果返回21007就再走沙盒环境去验证。 关于用户退款，需要服务端定期去向App Store去校验receipt，在返回来的数据中检查是否有 cancellation_date 字段，如果有值，则购买不成立。 欢迎指正😝 参考In-App Purchases in iOS With Swift 3苹果文档 About In-App Purchase苹果文档 验证Receipt]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>IAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Value and Reference Type]]></title>
    <url>%2F2017%2F06%2F03%2FValue-and-Reference-Type%2F</url>
    <content type="text"><![CDATA[Swift中值类型和引用类型本文主要介绍值类型、以及使用Struct作为数据模型的注意事项 值类型（value type）值类型：每次分配给变量/常量或者作为参数传递到函数时，都会重新创建（复制）一个新的实例。 Swift 中的所有的内建类型都是值类型，不仅包括了传统意义像 Int，Double这些，甚至连 String，Array 以及 Dictionary 都是值类型的(与OC不同), swift中所有的Struct 和 enum 都是值类型，值类型每次初始化以后，将它分配或者传递时，实际上是分配或传递了它的一个拷贝。 1234567891011121314struct Point &#123; var x : Int var y : Int init(x:Int, y:Int) &#123; self.x = x self.y = y &#125;&#125; var aPoint = Point(x: 10, y: 10) var bPoint = aPoint bPoint.x = 5 print(aPoint) print(bPoint) 打印结果 Point(x: 10, y: 10) Point(x: 5, y: 10) 总结： 赋值给新变量，会产生一个单独的、没有数据共享的新实例. 值类型在复制时，会将存储在其中的值类型一并进行复制，而对于其中的引用类型的话，则只复制一份引用。 复制时机，是在值类型中的内容发生改变时！值类型每次复制会增加额外开销，Swift将这种开销控制在最小的范围内，在没有必要复制时，复制是不会发生的。~(≧▽≦)/~ 线程安全： 在Swift中，Array、String、Dictionary都是值类型。它们的使用方式类似C语言中得int，每一个实例都有一份数据。你不需要进行显示的复制操作去防止数据在你不知情的情况下被修改。更重要的是，你可以跨线程进行传参而不需要考虑同步的问题，因为传递值类型很安全。（Swift官方博客） 引用类型（Reference Types）引用类型：引用类型初始化后，无论是分配给变量还是常量，或是通过参数传递给函数，都将是同一个实例对象。NSObject再熟悉不过了，当在分配或传递是都是引用，都指向那个原始对象。不再多说了~ Struct数据模型处理数据结构时有时会用Struct进行处理，使用 Struct 来代替 Class 作为数据模型有很多好处。值类型是非常有优势的： 安全性 ：因为 Struct 是用值类型传递的，它们没有引用计数。 内存：由于他们没有引用数，他们不会因为循环引用导致内存泄漏。 速度：值类型通常来说是以栈的形式分配的，而不是用堆。因此他们比 Class 要快很多，真的很多！在 StackOverflow 给 Struct 和 Class 进行相同操作的表现做了基准测试，Struct 比 Class 要快九百倍。 拷贝：在 Objective-C 里拷贝一个对象,你必须选用正确的拷贝类型（深拷贝、浅拷贝），这是非常烦人的，值类型的拷贝则非常轻松！ 线程安全：值类型是自动线程安全的。无论你从哪个线程去访问你的 Struct ，都非常简单。 Struct的缺点： OC无法调用Swift的Struct，当你的项目的代码是 Swift 和 Objective-C 混合开发时，你会发现在 Objective-C 的代码里无法调用 Swift 的 Struct。因为要在 Objective-C 里调用 Swift 代码的话，对象需要继承于 NSObject。 不能继承，继承是面向对象编程的四大特性之一，没有继承就不能抽象一个统一模型 Struct 不能被序列化成 NSData 对象。某些时候会把数据存在 NSUserDefaults 里，而Struct 转化成NSData，技术可行但坑多 参考： 王巍Swift Tips SwiftGG]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Heart Will Go On]]></title>
    <url>%2F2017%2F06%2F03%2FMy-Heart-Will-Go-On%2F</url>
    <content type="text"></content>
      <tags>
        <tag>慢时光</tag>
        <tag>生活</tag>
        <tag>梦想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F01%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>