<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NSURLProtocol黑魔法]]></title>
    <url>%2F2017%2F06%2F29%2FNSURLProtocol%E9%BB%91%E9%AD%94%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面的话 实际应用：在公司的海外项目中，在App中嵌入YouTube网页，当进入一个视频详情页时，视频会自动播放。而需求是不要自动播放，让用户点击我们自定义的播放按钮把视频投到电视上播放。下面让我们一起学习下如何拦截网络请求。 URL Loading System如图所示，URL Loading System是iOS一系列网络请求类的集合，包括已经过期不用的NSConnection和现在流行的NSURLSession，还包括一些请求认证的类，一个sessionConfig的类，还有关于处理请求缓存的类等，当然还包括我们要说的这个NSURLProtocol类。 NSURLProtocol NSURLProtocol可以让我们拦截程序中的一切网络请求，因为NSURLProtocol是一个虚基类，所以不能直接使用它，要想使用它就必须自定义一个类成为他的子类，然后实现他里面的必须实现的一些方法。主要进行如下拦截处理: 自定义请求 和 响应 过滤掉某些请求不让其发起、以及修改 提供 自定义的全局缓存 逻辑 重定向 网络请求 提供 HTTP Mocking (方便前期测试) 如何拦截网络请求注册自定义的URLProtocol子类 在appDelegate中，注册自己拦截请求的URLProtocol子类;相对应的也有unregistClass方法，不让某个子类起作用 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [NSURLProtocol registerClass:[WSURLProtocol class]]; return YES;&#125; 子类必须实现的方法 + (BOOL)canInitWithRequest:(NSURLRequest *)request每次有一个请求的时候都会调用这个方法，在这个方法里面判断这个请求是否需要被处理拦截，如果返回YES就代表这个request需要被处理，反之就是不需要被处理。 1234567891011121314+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123; //判断是否处理过，防止死循环 if ([NSURLProtocol propertyForKey:protocolKey inRequest:request]) &#123; return NO; &#125; //只拦截http和https请求 NSString *scheme = [[request URL] scheme]; if ([scheme caseInsensitiveCompare:@"http"] == NSOrderedSame || [scheme caseInsensitiveCompare:@"https"] == NSOrderedSame) &#123; return YES; &#125; return NO;&#125; + (NSURLRequest *) canonicalRequestForRequest:(NSURLRequest *)request 通常该方法你可以简单的直接返回request，但也可以在这里修改request，比如添加header，修改host等，并返回一个新的request，这是个抽象方法，子类必须实现。 123456+ (NSURLRequest *)canonicalRequestForRequest: (NSURLRequest *)request &#123; NSMutableURLRequest *request = [request mutableCopy]; //把访问百度的request改为访问Google了 request.URL = [NSURL URLWithString:@"http://www.google.com"]; return request;&#125; + (BOOL)requestIsCacheEquivalent:(NSURLRequest *)a toRequest:(NSURLRequest *)b 可用来使用缓存数据结束此次网络请求 - (void)startLoading 开始请求 123456789101112131415- (void)startLoading &#123; NSMutableURLRequest *request = [self.request mutableCopy]; // 标记request已处理 [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request]; //使用NSURLSession继续把重定向的request发送出去 NSURLSessionConfiguration *config = [NSURLSessionConfiguration ephemeralSessionConfiguration]; NSOperationQueue *mainQueue = [NSOperationQueue mainQueue]; NSURLSession *session = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:mainQueue]; NSURLSessionDataTask *task = [session dataTaskWithRequest:request]; [task resume];&#125; -(void)stopLoading 停止请求的方法，也是要实现的。 NSURLProtocolClient如果我们使用UIWebView发送一个request，拦截以后当我们使用NSURLSession发出了request，那么这个request的response是无法回到这个UIWebView的，因为可以理解成不是同一个地方发出的request，这个response只能有session来处理，那我们怎么才能让这个response回到刚开始的UIWebView呢？ NSURLProtocolClient就可以看做是URL Loading System，我们把response告诉client，也就是URL Loading System，让他来继续处理这个response，因为一切都是基于URL Loading System发生的，所以把response交给他，他会自动处理这个response回到webView。 每一个NSURLProtocol的子类都有一个client对象来处理请求得到的response。其实下面这些写法都是差不多固定的。 12345678910111213141516171819-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123; if (error) &#123; [self.client URLProtocol:self didFailWithError:error]; &#125; else &#123; [self.client URLProtocolDidFinishLoading:self]; &#125;&#125;-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler &#123; [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed]; completionHandler(NSURLSessionResponseAllow);&#125;-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123; [self.client URLProtocol:self didLoadData:data];&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler&#123; completionHandler(proposedResponse);&#125; 总结 防止死循环 [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request]; NSURLProtocol 可以拦截 NSURLConnection、NSURLSession、UIwebview 的请求，但是不能拦截WKwebview 和CFNetwork的请求 AFNetworking 3.0 以后版本拦截不到请求，session的创建方式不同，默认不起作用，解决方法 参考田腾飞的博客幻想乡]]></content>
      <tags>
        <tag>网络</tag>
        <tag>NSURLProtocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TVOS开发技巧]]></title>
    <url>%2F2017%2F06%2F19%2FTVOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[焦点 ImageView自带focus特效 guideFocus na]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>TVOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS应用内购买IAP]]></title>
    <url>%2F2017%2F06%2F13%2FiOS%E5%BA%94%E7%94%A8%E5%86%85%E8%B4%AD%E4%B9%B0IAP%2F</url>
    <content type="text"><![CDATA[iOS应用内购买IAP 最近苹果针对iOS应用软件开发者的指引政策进行了修改，，第一次明确指出用户支付小费或者打赏，必须通过苹果的支付渠道，也就是不能绕开苹果iOS管理机制。微信在iOS版本取消了打赏功能，知乎则是向苹果低了头…苹果在相关文档中提到，如果开发者想在iOS软件提供下述功能（比如用户订阅、游戏内虚拟货币、获取高端会员内容、或者提供完整的功能版本等），则开发者必须使用软件内购买。 本文主要以自动订阅类型产品为主，其他类型产品为辅 准备In-App Purchase， 简称IAP，允许在iOS app与macOS app中出售商品。 新建一个app，然后添加App 内购买项目，主要分四种内购买项目类型。 消耗品（Consumable products）：会越用越少的，比如游戏内金币等。 不可消耗品（Non-consumable products）：比如游戏中跑车，简单来说就是一次购买，终身可用（用户可随时从App Store restore） 自动更新订阅品（Auto-renewable subscriptions）：和不可消耗品的不同点是有失效时间。比如一整年的付费周刊。在这种模式下，开发者定期投递内容，用户在订阅期内随时可以访问这些内容。订阅快要过期时，系统将自动更新订阅。 非自动更新订阅品（Non-renewable subscriptions）：一般使用场景是从用户从IAP购买后，购买信息存放在自己的开发者服务器上。失效日期/可用是由开发者服务器自行控制的，而非由App Store控制，这一点与自动更新订阅品有差异。 添加APP内购买项目 设置税务和银行卡信息 添加沙盒测试账号 使用StoreKit API 获取产品列表，展现的产品可以后台配置(Consumable可消耗商品举例) 12345678910111213141516171819202122232425262728293031323334// MARK: - FETCH AVAILABLE IAP PRODUCTS func fetchAvailableProducts() &#123; Toast(text: "fetching available products").show() // Put here your IAP Products ID's let productIdentifiers = NSSet(objects: COINS_PRODUCT_ID,PREMIUM_PRODUCT_ID ) productsRequest = SKProductsRequest(productIdentifiers: productIdentifiers as! Set&lt;String&gt;) productsRequest.delegate = self productsRequest.start() &#125; // MARK: - REQUEST IAP PRODUCTS func productsRequest (_ request:SKProductsRequest, didReceive response:SKProductsResponse) &#123; if (response.products.count &gt; 0) &#123; Toast(text: "fetch \(response.products.count) product success").show() iapProducts = response.products // 1st IAP Product (Consumable) ------------------------------------ let firstProduct = response.products[0] as SKProduct // Get its price from iTunes Connect let numberFormatter = NumberFormatter() numberFormatter.formatterBehavior = .behavior10_4 numberFormatter.numberStyle = .currency numberFormatter.locale = firstProduct.priceLocale let price1Str = numberFormatter.string(from: firstProduct.price) // Show its description consumableLabel.text = firstProduct.localizedDescription + "\nfor just \(price1Str!)" &#125; &#125; 购买产品，首先检查设备是否支持内购买，然后将交易加入支付队列 123456789101112131415161718192021// MARK: - MAKE PURCHASE OF A PRODUCT func canMakePurchases() -&gt; Bool &#123; return SKPaymentQueue.canMakePayments() &#125; func purchaseMyProduct(product: SKProduct) &#123; if self.canMakePurchases() &#123; Toast(text: "begin purchase for \(product.localizedTitle)").show() let payment = SKPayment(product: product) SKPaymentQueue.default().add(self) SKPaymentQueue.default().add(payment) print("PRODUCT TO PURCHASE: \(product.productIdentifier)") productID = product.productIdentifier // IAP Purchases dsabled on the Device &#125; else &#123; UIAlertView(title: "IAP Tutorial", message: "Purchases are disabled in your device!", delegate: nil, cancelButtonTitle: "OK").show() &#125; &#125; 处理支付结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// MARK:- IAP PAYMENT QUEUE func paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]) &#123; for transaction:AnyObject in transactions &#123; if let trans = transaction as? SKPaymentTransaction &#123; let msg = self.descFromTransactionState(trans.transactionState); if(msg != nil)&#123; Toast(text: msg).show() &#125; switch trans.transactionState &#123; case .purchased: SKPaymentQueue.default().finishTransaction(transaction as! SKPaymentTransaction) guard let receiptUrl = Bundle.main.appStoreReceiptURL else &#123; SKPaymentQueue.default() return &#125; let receipt = try? Data.init(contentsOf: receiptUrl) //自动订阅类型需要验证receipt 发到 apple guard let receiptBase64String = receipt?.base64EncodedString() else &#123; return &#125; let dict = ["receipt-data": receiptBase64String] let url:URL? = URL(string:"https://sandbox.itunes.apple.com/verifyReceipt") var request = URLRequest.init(url: url!) request.httpMethod = "POST" let data = try? JSONSerialization.data(withJSONObject: dict, options: JSONSerialization.WritingOptions.prettyPrinted) request.httpBody = data URLSession.shared.dataTask(with: request, completionHandler: &#123; (data, response, error) in if(data != nil)&#123; let JSONObj = try? JSONSerialization.jsonObject(with: data!, options: .allowFragments) let str = String(data: data!, encoding: .utf8) print(str!) print(JSONObj!) &#125; &#125;).resume() break case .failed: SKPaymentQueue.default().finishTransaction(transaction as! SKPaymentTransaction) break case .restored: SKPaymentQueue.default().finishTransaction(transaction as! SKPaymentTransaction) break default: break &#125;&#125;&#125; &#125; 使用SwiftyStoreKit库简化调用API SwiftyStoreKit对StoreKit的api进行封装，调用起来更加方便。具体api请参考SwiftyStoreKit Github 需要注意的购买商品时api 区分原子性和非原子性；原子性是购买成功后，购买的内容能立即传递给用户界面，而非原子性是指购买的内容需要从服务器下载，需要下载完毕，才调用完成交易的api来结束交易 12345678910111213141516171819202122SwiftyStoreKit.purchaseProduct("com.musevisions.SwiftyStoreKit.Purchase1", quantity: 1, atomically: false) &#123; result in switch result &#123; case .success(let product): // fetch content from your server, then: if product.needsFinishTransaction &#123; SwiftyStoreKit.finishTransaction(product.transaction) &#125; print("Purchase Success: \(product.productId)") case .error(let error): switch error.code &#123; case .unknown: print("Unknown error. Please contact support") case .clientInvalid: print("Not allowed to make the payment") case .paymentCancelled: break case .paymentInvalid: print("The purchase identifier was invalid") case .paymentNotAllowed: print("The device is not allowed to make the payment") case .storeProductNotAvailable: print("The product is not available in the current storefront") case .cloudServicePermissionDenied: print("Access to cloud service information is not allowed") case .cloudServiceNetworkConnectionFailed: print("Could not connect to the network") case .cloudServiceRevoked: print("User has revoked permission to use this cloud service") &#125; &#125;&#125; 自动订阅类型总结 注册在AppDelegate中didFinishLaunchingWithOptions中，注册交易观察者，这样app就可以收到支付队列的通知（自动续订时会被调用） 沙盒测试周期会被加速，订阅周期为1周，在沙盒环境下只需3分钟，1个月只需5分钟…苹果考虑的挺周到的 一个沙盒测试账号一天只能被更新订阅5次，测试自动订阅时尤其注意，可以使用多个测试账号（当时我以为没能自动订阅呢） 客户端先将receipt发给服务端，服务端去验证receipt 有时返回 210007 状态码，意味着这个receipt是测试环境的，但发送到了正式环境https://buy.itunes.apple.com/verifyReceip。而且审核时，苹果人员也是用沙盒环境测试，如何切换正式和测试环境呢？解决方案：服务端先走正式环境，如果返回21007就再走沙盒环境去验证。 关于用户退款，需要服务端定期去向App Store去校验receipt，在返回来的数据中检查是否有 cancellation_date 字段，如果有值，则购买不成立。 欢迎指正😝 参考In-App Purchases in iOS With Swift 3苹果文档 About In-App Purchase苹果文档 验证Receipt]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>IAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Value and Reference Type]]></title>
    <url>%2F2017%2F06%2F03%2FValue-and-Reference-Type%2F</url>
    <content type="text"><![CDATA[Swift中值类型和引用类型本文主要介绍值类型、以及使用Struct作为数据模型的注意事项 值类型（value type）值类型：每次分配给变量/常量或者作为参数传递到函数时，都会重新创建（复制）一个新的实例。 Swift 中的所有的内建类型都是值类型，不仅包括了传统意义像 Int，Double这些，甚至连 String，Array 以及 Dictionary 都是值类型的(与OC不同), swift中所有的Struct 和 enum 都是值类型，值类型每次初始化以后，将它分配或者传递时，实际上是分配或传递了它的一个拷贝。 1234567891011121314struct Point &#123; var x : Int var y : Int init(x:Int, y:Int) &#123; self.x = x self.y = y &#125;&#125; var aPoint = Point(x: 10, y: 10) var bPoint = aPoint bPoint.x = 5 print(aPoint) print(bPoint) 打印结果 Point(x: 10, y: 10) Point(x: 5, y: 10) 总结： 赋值给新变量，会产生一个单独的、没有数据共享的新实例. 值类型在复制时，会将存储在其中的值类型一并进行复制，而对于其中的引用类型的话，则只复制一份引用。 复制时机，是在值类型中的内容发生改变时！值类型每次复制会增加额外开销，Swift将这种开销控制在最小的范围内，在没有必要复制时，复制是不会发生的。~(≧▽≦)/~ 线程安全： 在Swift中，Array、String、Dictionary都是值类型。它们的使用方式类似C语言中得int，每一个实例都有一份数据。你不需要进行显示的复制操作去防止数据在你不知情的情况下被修改。更重要的是，你可以跨线程进行传参而不需要考虑同步的问题，因为传递值类型很安全。（Swift官方博客） 引用类型（Reference Types）引用类型：引用类型初始化后，无论是分配给变量还是常量，或是通过参数传递给函数，都将是同一个实例对象。NSObject再熟悉不过了，当在分配或传递是都是引用，都指向那个原始对象。不再多说了~ Struct数据模型处理数据结构时有时会用Struct进行处理，使用 Struct 来代替 Class 作为数据模型有很多好处。值类型是非常有优势的： 安全性 ：因为 Struct 是用值类型传递的，它们没有引用计数。 内存：由于他们没有引用数，他们不会因为循环引用导致内存泄漏。 速度：值类型通常来说是以栈的形式分配的，而不是用堆。因此他们比 Class 要快很多，真的很多！在 StackOverflow 给 Struct 和 Class 进行相同操作的表现做了基准测试，Struct 比 Class 要快九百倍。 拷贝：在 Objective-C 里拷贝一个对象,你必须选用正确的拷贝类型（深拷贝、浅拷贝），这是非常烦人的，值类型的拷贝则非常轻松！ 线程安全：值类型是自动线程安全的。无论你从哪个线程去访问你的 Struct ，都非常简单。 Struct的缺点： OC无法调用Swift的Struct，当你的项目的代码是 Swift 和 Objective-C 混合开发时，你会发现在 Objective-C 的代码里无法调用 Swift 的 Struct。因为要在 Objective-C 里调用 Swift 代码的话，对象需要继承于 NSObject。 不能继承，继承是面向对象编程的四大特性之一，没有继承就不能抽象一个统一模型 Struct 不能被序列化成 NSData 对象。某些时候会把数据存在 NSUserDefaults 里，而Struct 转化成NSData，技术可行但坑多 参考： 王巍Swift Tips SwiftGG]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Heart Will Go On]]></title>
    <url>%2F2017%2F06%2F03%2FMy-Heart-Will-Go-On%2F</url>
    <content type="text"></content>
      <tags>
        <tag>慢时光</tag>
        <tag>生活</tag>
        <tag>梦想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F01%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>