<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python爬虫]]></title>
    <url>%2F2017%2F09%2F15%2Fpython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[RxSwift实践]]></title>
    <url>%2F2017%2F09%2F03%2FRxSwift%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[NSURLProtocol黑魔法]]></title>
    <url>%2F2017%2F06%2F29%2FNSURLProtocol%E9%BB%91%E9%AD%94%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面的话 实际应用：在公司的海外项目中，在App中嵌入YouTube网页，当进入一个视频详情页时，视频会自动播放。而需求是不要自动播放，让用户点击我们自定义的播放按钮把视频投到电视上播放。下面让我们一起学习下如何拦截网络请求。 URL Loading System如图所示，URL Loading System是iOS一系列网络请求类的集合，包括已经过期不用的NSConnection和现在流行的NSURLSession，还包括一些请求认证的类，一个sessionConfig的类，还有关于处理请求缓存的类等，当然还包括我们要说的这个NSURLProtocol类。 NSURLProtocol NSURLProtocol可以让我们拦截程序中的一切网络请求，因为NSURLProtocol是一个虚基类，所以不能直接使用它，要想使用它就必须自定义一个类成为他的子类，然后实现他里面的必须实现的一些方法。主要进行如下拦截处理: 自定义请求 和 响应 过滤掉某些请求不让其发起、以及修改 提供 自定义的全局缓存 逻辑 重定向 网络请求 提供 HTTP Mocking (方便前期测试) 如何拦截网络请求注册自定义的URLProtocol子类 在appDelegate中，注册自己拦截请求的URLProtocol子类;相对应的也有unregistClass方法，不让某个子类起作用 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [NSURLProtocol registerClass:[WSURLProtocol class]]; return YES;&#125; 子类必须实现的方法 + (BOOL)canInitWithRequest:(NSURLRequest *)request每次有一个请求的时候都会调用这个方法，在这个方法里面判断这个请求是否需要被处理拦截，如果返回YES就代表这个request需要被处理，反之就是不需要被处理。 1234567891011121314+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123; //判断是否处理过，防止死循环 if ([NSURLProtocol propertyForKey:protocolKey inRequest:request]) &#123; return NO; &#125; //只拦截http和https请求 NSString *scheme = [[request URL] scheme]; if ([scheme caseInsensitiveCompare:@"http"] == NSOrderedSame || [scheme caseInsensitiveCompare:@"https"] == NSOrderedSame) &#123; return YES; &#125; return NO;&#125; + (NSURLRequest *) canonicalRequestForRequest:(NSURLRequest *)request 通常该方法你可以简单的直接返回request，但也可以在这里修改request，比如添加header，修改host等，并返回一个新的request，这是个抽象方法，子类必须实现。 123456+ (NSURLRequest *)canonicalRequestForRequest: (NSURLRequest *)request &#123; NSMutableURLRequest *request = [request mutableCopy]; //把访问百度的request改为访问Google了 request.URL = [NSURL URLWithString:@"http://www.google.com"]; return request;&#125; + (BOOL)requestIsCacheEquivalent:(NSURLRequest *)a toRequest:(NSURLRequest *)b 可用来使用缓存数据结束此次网络请求 - (void)startLoading 开始请求 123456789101112131415- (void)startLoading &#123; NSMutableURLRequest *request = [self.request mutableCopy]; // 标记request已处理 [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request]; //使用NSURLSession继续把重定向的request发送出去 NSURLSessionConfiguration *config = [NSURLSessionConfiguration ephemeralSessionConfiguration]; NSOperationQueue *mainQueue = [NSOperationQueue mainQueue]; NSURLSession *session = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:mainQueue]; NSURLSessionDataTask *task = [session dataTaskWithRequest:request]; [task resume];&#125; -(void)stopLoading 停止请求的方法，也是要实现的。 NSURLProtocolClient如果我们使用UIWebView发送一个request，拦截以后当我们使用NSURLSession发出了request，那么这个request的response是无法回到这个UIWebView的，因为可以理解成不是同一个地方发出的request，这个response只能有session来处理，那我们怎么才能让这个response回到刚开始的UIWebView呢？ NSURLProtocolClient就可以看做是URL Loading System，我们把response告诉client，也就是URL Loading System，让他来继续处理这个response，因为一切都是基于URL Loading System发生的，所以把response交给他，他会自动处理这个response回到webView。 每一个NSURLProtocol的子类都有一个client对象来处理请求得到的response。其实下面这些写法都是差不多固定的。 12345678910111213141516171819-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123; if (error) &#123; [self.client URLProtocol:self didFailWithError:error]; &#125; else &#123; [self.client URLProtocolDidFinishLoading:self]; &#125;&#125;-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler &#123; [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed]; completionHandler(NSURLSessionResponseAllow);&#125;-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123; [self.client URLProtocol:self didLoadData:data];&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler&#123; completionHandler(proposedResponse);&#125; 总结 防止死循环 [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request]; NSURLProtocol 可以拦截 NSURLConnection、NSURLSession、UIwebview 的请求，但是不能拦截WKwebview 和CFNetwork的请求 AFNetworking 3.0 以后版本拦截不到请求，session的创建方式不同，默认不起作用，解决方法 参考田腾飞的博客幻想乡]]></content>
      <tags>
        <tag>NetWork</tag>
        <tag>NSURLProtocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TVOS开发技巧]]></title>
    <url>%2F2017%2F06%2F19%2FTVOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[写在前面的话 之前一直觉得Apple TV 是个神奇的东西，迷一样的事物。国内基本见不到它的影子，而公司要做一个Apple TV app，作为一名”资深”iOS开发者，怎么能不兴奋呢😝在使用Apple TV之后，感觉真的比国内安卓系统的智能电视要惊艳很多，遥控器都那么与众不同！操作方便，也赏心悦目；缺点是不能看各个电视频道 前期调研 相关资料很少，国内基本没有啥资料，只能看英文资料啦！推荐一本书籍《tvOS Apprentice》入门 使用Swift进行开发，国外资料基本都用Swift写，赶紧上船… 讲点有趣的UIView的focus特效 在电视屏幕上你看到App里展示的界面，大部分都是UIImageView呈现的，图片比文字更能吸引眼球。看到没有，但你用手指在遥控器触摸区打转时，获得焦点的图片会被放大，随手指旋转并带有眩光的视觉！这样的效果，只需设置UIImageView的自带属性：adjustsImageWhenAncestorFocused即可，真棒！！！ UIView 有个属性canBecomeFocused可以设置是否能获得焦点状态，设置为true，然后重写didUpdateFocus()方法 1234567891011121314override func didUpdateFocus(in context: UIFocusUpdateContext, with coordinator: UIFocusAnimationCoordinator) &#123; if context.nextFocusedView == self &#123; // 获得焦点 self.transform = CGAffineTransform(scaleX: 1.1, y: 1.1) self.layer.shadowColor = UIColor.black.alpha(0.36).cgColor self.layer.shadowOffset = CGSize(width: 0, height: 30) //设置阴影，模糊效果的半径 self.layer.shadowRadius = 50 self.layer.shadowOpacity = 1.0 &#125;else&#123; //失去焦点 self.transform = CGAffineTransform.identity self.layer.shadowOpacity = 0.0 &#125; &#125; 下面再看一个有意思的 UIImageView的animationImages可以设置一组图片，然后让图片动起来~可是当你把一组表情图片设置给animationImages，ImageView获得焦点时，表情并没有动啊！ 解决方法：将UIImageView加到一个UIView上，当view获得焦点时，view调整transform的scale，并让imageView开始startAnimating；失去焦点时，将view的transform还原，imageViewstopAnimating。 如何控制焦点Focus Engine（焦点引擎） 我们可以将Focus视为聚光灯，将用户的注意力引导到屏幕上的特定元素。视图可以突出显示或聚焦，用户可以使用遥控器将焦点移动到应用的不同元素。 当用户在遥控器的触摸面上滑动时，焦点引擎将朝着移动焦点的下一个视图的方向移动。如果它“看到”一个，它将Focus放在那里，如果没有看到它，它不会移动Focus。 例如：下面简单的3个按钮应用程序，当右上方的按钮处于焦点状态，用户向下滑动，想滑动到左下方按钮，因为焦点引擎看不到任何视图，所以Focus不会移动。 这时候该 UIFocusGuide 登场了 UIFocusGuideUIFocusGuide ：是不可见的布局指导，可帮助Focus Engine知道将Focus移动到哪里。我们把FocusGuide放到右下方，效果就像下图 代码首先，我们添加焦点指南的视图。 123456789// Create the Focus Guide and add it to the viewvar focusGuide = UIFocusGuide()view.addLayoutGuide(focusGuide)// Anchor the Focus Guide focusGuide.widthAnchor.constraintEqualToAnchor(topRightButton.widthAnchor).active = truefocusGuide.heightAnchor.constraintEqualToAnchor(bottomLeftButton.heightAnchor).active = truefocusGuide.topAnchor.constraintEqualToAnchor(bottomLeftButton.topAnchor).active = truefocusGuide.leftAnchor.constraintEqualToAnchor(topRightButton.leftAnchor).active = true 然后，要使焦点指南直接聚焦到左下方的按钮，我们设置焦点指南的preferredFocusView属性; 这是“焦点指南”将引导焦点的view。 12// Set preferred focus focusGuide.preferredFocusedView = bottomLeftButton 调试如果它们没有起作用，如何调试”焦点指南”呢？苹果提供两种方式： Quick Look(快速查看) _whyIsThisViewNotFocusable 快速查看Quick Look是一款用于调试Focus Engine和Focus Guide问题的可视化工具。要使用它，你必须在方法中得到一个中断didUpdateFocusInContext(context, withAnimationCoordinator coordinator); 每次焦点被移动时都会被调用。然后，在Xcode左下角的Varibles视图中，突出显示context变量，然后单击底部的眼睛图标（或按空格键）。 whyIsThisViewNotFocusable苹果还提供了（非常描述性地命名）LLDB命令，_whyIsThisViewNotFocusable称为另一个Focus调试工具。 要使用此命令，您需要在代码中的任何位置（或者甚至暂停它）中断中断，并_whyIsThisViewNotFocusable在LLDB命令行调试器中运行命令，如下所示： 1[yourView _whyIsThisViewNotFocusable] Swift命令是： 1po yourView.performSelector(Selector("_whyIsThisViewNotFocusable")) 第三个方法Visual Focus GuidesGithub地址 再吐槽一下给图片加圆角 12self.bgImageV.layer.masksToBounds = true self.bgImageV.layer.cornerRadius = 10 TVOS上可没这么简单，这么做的后果是当图片在焦点状态时，图片放大的部分会被裁剪，这太坑了~😢 123456789// Kingfisher库的生成圆角方法///下载网络图片let processor = RoundCornerImageProcessor(cornerRadius: 6) ImageView.kf.setImage(with: model?.image, placeholder: nil, options: [.processor(processor)]) ///本地图片 let image = UIImage.createImage(color: UIColor("#908F8F"), cornerRadius: 0, size: CGSize(width: 10, height: 10)) //fit 一定要是UIImageView的size大小 ImageView.image = image.kf.image(withRoundRadius: 6, fit: ImageView.size) 为啥在TVApp不能给UIImageView设置圆角呢？苹果怎么考虑的？可能是个bug！ 参考Debugging Focus in tvOS]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>TVOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS应用内购买IAP]]></title>
    <url>%2F2017%2F06%2F13%2FiOS%E5%BA%94%E7%94%A8%E5%86%85%E8%B4%AD%E4%B9%B0IAP%2F</url>
    <content type="text"><![CDATA[iOS应用内购买IAP 最近苹果针对iOS应用软件开发者的指引政策进行了修改，，第一次明确指出用户支付小费或者打赏，必须通过苹果的支付渠道，也就是不能绕开苹果iOS管理机制。微信在iOS版本取消了打赏功能，知乎则是向苹果低了头…苹果在相关文档中提到，如果开发者想在iOS软件提供下述功能（比如用户订阅、游戏内虚拟货币、获取高端会员内容、或者提供完整的功能版本等），则开发者必须使用软件内购买。 本文主要以自动订阅类型产品为主，其他类型产品为辅 准备In-App Purchase， 简称IAP，允许在iOS app与macOS app中出售商品。 新建一个app，然后添加App 内购买项目，主要分四种内购买项目类型。 消耗品（Consumable products）：会越用越少的，比如游戏内金币等。 不可消耗品（Non-consumable products）：比如游戏中跑车，简单来说就是一次购买，终身可用（用户可随时从App Store restore） 自动更新订阅品（Auto-renewable subscriptions）：和不可消耗品的不同点是有失效时间。比如一整年的付费周刊。在这种模式下，开发者定期投递内容，用户在订阅期内随时可以访问这些内容。订阅快要过期时，系统将自动更新订阅。 非自动更新订阅品（Non-renewable subscriptions）：一般使用场景是从用户从IAP购买后，购买信息存放在自己的开发者服务器上。失效日期/可用是由开发者服务器自行控制的，而非由App Store控制，这一点与自动更新订阅品有差异。 添加APP内购买项目 设置税务和银行卡信息 添加沙盒测试账号 使用StoreKit API 获取产品列表，展现的产品可以后台配置(Consumable可消耗商品举例) 12345678910111213141516171819202122232425262728293031323334// MARK: - FETCH AVAILABLE IAP PRODUCTS func fetchAvailableProducts() &#123; Toast(text: "fetching available products").show() // Put here your IAP Products ID's let productIdentifiers = NSSet(objects: COINS_PRODUCT_ID,PREMIUM_PRODUCT_ID ) productsRequest = SKProductsRequest(productIdentifiers: productIdentifiers as! Set&lt;String&gt;) productsRequest.delegate = self productsRequest.start() &#125; // MARK: - REQUEST IAP PRODUCTS func productsRequest (_ request:SKProductsRequest, didReceive response:SKProductsResponse) &#123; if (response.products.count &gt; 0) &#123; Toast(text: "fetch \(response.products.count) product success").show() iapProducts = response.products // 1st IAP Product (Consumable) ------------------------------------ let firstProduct = response.products[0] as SKProduct // Get its price from iTunes Connect let numberFormatter = NumberFormatter() numberFormatter.formatterBehavior = .behavior10_4 numberFormatter.numberStyle = .currency numberFormatter.locale = firstProduct.priceLocale let price1Str = numberFormatter.string(from: firstProduct.price) // Show its description consumableLabel.text = firstProduct.localizedDescription + "\nfor just \(price1Str!)" &#125; &#125; 购买产品，首先检查设备是否支持内购买，然后将交易加入支付队列 123456789101112131415161718192021// MARK: - MAKE PURCHASE OF A PRODUCT func canMakePurchases() -&gt; Bool &#123; return SKPaymentQueue.canMakePayments() &#125; func purchaseMyProduct(product: SKProduct) &#123; if self.canMakePurchases() &#123; Toast(text: "begin purchase for \(product.localizedTitle)").show() let payment = SKPayment(product: product) SKPaymentQueue.default().add(self) SKPaymentQueue.default().add(payment) print("PRODUCT TO PURCHASE: \(product.productIdentifier)") productID = product.productIdentifier // IAP Purchases dsabled on the Device &#125; else &#123; UIAlertView(title: "IAP Tutorial", message: "Purchases are disabled in your device!", delegate: nil, cancelButtonTitle: "OK").show() &#125; &#125; 处理支付结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// MARK:- IAP PAYMENT QUEUE func paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]) &#123; for transaction:AnyObject in transactions &#123; if let trans = transaction as? SKPaymentTransaction &#123; let msg = self.descFromTransactionState(trans.transactionState); if(msg != nil)&#123; Toast(text: msg).show() &#125; switch trans.transactionState &#123; case .purchased: SKPaymentQueue.default().finishTransaction(transaction as! SKPaymentTransaction) guard let receiptUrl = Bundle.main.appStoreReceiptURL else &#123; SKPaymentQueue.default() return &#125; let receipt = try? Data.init(contentsOf: receiptUrl) //自动订阅类型需要验证receipt 发到 apple guard let receiptBase64String = receipt?.base64EncodedString() else &#123; return &#125; let dict = ["receipt-data": receiptBase64String] let url:URL? = URL(string:"https://sandbox.itunes.apple.com/verifyReceipt") var request = URLRequest.init(url: url!) request.httpMethod = "POST" let data = try? JSONSerialization.data(withJSONObject: dict, options: JSONSerialization.WritingOptions.prettyPrinted) request.httpBody = data URLSession.shared.dataTask(with: request, completionHandler: &#123; (data, response, error) in if(data != nil)&#123; let JSONObj = try? JSONSerialization.jsonObject(with: data!, options: .allowFragments) let str = String(data: data!, encoding: .utf8) print(str!) print(JSONObj!) &#125; &#125;).resume() break case .failed: SKPaymentQueue.default().finishTransaction(transaction as! SKPaymentTransaction) break case .restored: SKPaymentQueue.default().finishTransaction(transaction as! SKPaymentTransaction) break default: break &#125;&#125;&#125; &#125; 使用SwiftyStoreKit库简化调用API SwiftyStoreKit对StoreKit的api进行封装，调用起来更加方便。具体api请参考SwiftyStoreKit Github 需要注意的购买商品时api 区分原子性和非原子性；原子性是购买成功后，购买的内容能立即传递给用户界面，而非原子性是指购买的内容需要从服务器下载，需要下载完毕，才调用完成交易的api来结束交易 12345678910111213141516171819202122SwiftyStoreKit.purchaseProduct("com.musevisions.SwiftyStoreKit.Purchase1", quantity: 1, atomically: false) &#123; result in switch result &#123; case .success(let product): // fetch content from your server, then: if product.needsFinishTransaction &#123; SwiftyStoreKit.finishTransaction(product.transaction) &#125; print("Purchase Success: \(product.productId)") case .error(let error): switch error.code &#123; case .unknown: print("Unknown error. Please contact support") case .clientInvalid: print("Not allowed to make the payment") case .paymentCancelled: break case .paymentInvalid: print("The purchase identifier was invalid") case .paymentNotAllowed: print("The device is not allowed to make the payment") case .storeProductNotAvailable: print("The product is not available in the current storefront") case .cloudServicePermissionDenied: print("Access to cloud service information is not allowed") case .cloudServiceNetworkConnectionFailed: print("Could not connect to the network") case .cloudServiceRevoked: print("User has revoked permission to use this cloud service") &#125; &#125;&#125; 自动订阅类型总结 注册在AppDelegate中didFinishLaunchingWithOptions中，注册交易观察者，这样app就可以收到支付队列的通知（自动续订时会被调用） 沙盒测试周期会被加速，订阅周期为1周，在沙盒环境下只需3分钟，1个月只需5分钟…苹果考虑的挺周到的 一个沙盒测试账号一天只能被更新订阅5次，测试自动订阅时尤其注意，可以使用多个测试账号（当时我以为没能自动订阅呢） 客户端先将receipt发给服务端，服务端去验证receipt 有时返回 210007 状态码，意味着这个receipt是测试环境的，但发送到了正式环境https://buy.itunes.apple.com/verifyReceip。而且审核时，苹果人员也是用沙盒环境测试，如何切换正式和测试环境呢？解决方案：服务端先走正式环境，如果返回21007就再走沙盒环境去验证。 关于用户退款，需要服务端定期去向App Store去校验receipt，在返回来的数据中检查是否有 cancellation_date 字段，如果有值，则购买不成立。 欢迎指正😝 参考In-App Purchases in iOS With Swift 3苹果文档 About In-App Purchase苹果文档 验证Receipt]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>IAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Value and Reference Type]]></title>
    <url>%2F2017%2F06%2F03%2FValue-and-Reference-Type%2F</url>
    <content type="text"><![CDATA[Swift中值类型和引用类型本文主要介绍值类型、以及使用Struct作为数据模型的注意事项 值类型（value type）值类型：每次分配给变量/常量或者作为参数传递到函数时，都会重新创建（复制）一个新的实例。 Swift 中的所有的内建类型都是值类型，不仅包括了传统意义像 Int，Double这些，甚至连 String，Array 以及 Dictionary 都是值类型的(与OC不同), swift中所有的Struct 和 enum 都是值类型，值类型每次初始化以后，将它分配或者传递时，实际上是分配或传递了它的一个拷贝。 1234567891011121314struct Point &#123; var x : Int var y : Int init(x:Int, y:Int) &#123; self.x = x self.y = y &#125;&#125; var aPoint = Point(x: 10, y: 10) var bPoint = aPoint bPoint.x = 5 print(aPoint) print(bPoint) 打印结果 Point(x: 10, y: 10) Point(x: 5, y: 10) 总结： 赋值给新变量，会产生一个单独的、没有数据共享的新实例. 值类型在复制时，会将存储在其中的值类型一并进行复制，而对于其中的引用类型的话，则只复制一份引用。 复制时机，是在值类型中的内容发生改变时！值类型每次复制会增加额外开销，Swift将这种开销控制在最小的范围内，在没有必要复制时，复制是不会发生的。~(≧▽≦)/~ 线程安全： 在Swift中，Array、String、Dictionary都是值类型。它们的使用方式类似C语言中得int，每一个实例都有一份数据。你不需要进行显示的复制操作去防止数据在你不知情的情况下被修改。更重要的是，你可以跨线程进行传参而不需要考虑同步的问题，因为传递值类型很安全。（Swift官方博客） 引用类型（Reference Types）引用类型：引用类型初始化后，无论是分配给变量还是常量，或是通过参数传递给函数，都将是同一个实例对象。NSObject再熟悉不过了，当在分配或传递是都是引用，都指向那个原始对象。不再多说了~ Struct数据模型处理数据结构时有时会用Struct进行处理，使用 Struct 来代替 Class 作为数据模型有很多好处。值类型是非常有优势的： 安全性 ：因为 Struct 是用值类型传递的，它们没有引用计数。 内存：由于他们没有引用数，他们不会因为循环引用导致内存泄漏。 速度：值类型通常来说是以栈的形式分配的，而不是用堆。因此他们比 Class 要快很多，真的很多！在 StackOverflow 给 Struct 和 Class 进行相同操作的表现做了基准测试，Struct 比 Class 要快九百倍。 拷贝：在 Objective-C 里拷贝一个对象,你必须选用正确的拷贝类型（深拷贝、浅拷贝），这是非常烦人的，值类型的拷贝则非常轻松！ 线程安全：值类型是自动线程安全的。无论你从哪个线程去访问你的 Struct ，都非常简单。 Struct的缺点： OC无法调用Swift的Struct，当你的项目的代码是 Swift 和 Objective-C 混合开发时，你会发现在 Objective-C 的代码里无法调用 Swift 的 Struct。因为要在 Objective-C 里调用 Swift 代码的话，对象需要继承于 NSObject。 不能继承，继承是面向对象编程的四大特性之一，没有继承就不能抽象一个统一模型 Struct 不能被序列化成 NSData 对象。某些时候会把数据存在 NSUserDefaults 里，而Struct 转化成NSData，技术可行但坑多 参考： 王巍Swift Tips SwiftGG]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Heart Will Go On]]></title>
    <url>%2F2017%2F06%2F03%2FWillishine%E7%9A%84%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[如果想要成功，那就要努力；光努力还不够，还要坚持，如果坚持不了，那就不要抱怨… 自己有多想成功？当你想成功的欲望强烈的像想要呼吸一样，成功才更有可能… “人生没有彩排，每一天都是现场直播”。偶尔会想，如果人生真如一场电子游戏，玩坏了可以选择重来，生活会变成什么样子？正因为时光流逝一去不复返，每一天都不可追回，所以更要珍惜每一寸光阴，孝敬父母、疼爱孩子、体贴爱人、善待朋友！ 我想要纯粹的生活想要奋斗的喜悦想要健康的体魄想要一个有趣的灵魂二十六的我，仍然渴望出发…]]></content>
      <tags>
        <tag>慢时光</tag>
        <tag>生活</tag>
        <tag>梦想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC和JavaScript交互]]></title>
    <url>%2F2017%2F05%2F23%2FOC%E5%92%8CJavaScript%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[UIWebView与JavaScript交互基本的概念 JavaScriptCore是封装了JavaScript和Objective-C桥接的Objective-C API，只要用很少的代码，就可以做到JavaScript调用Objective-C，或者Objective-C调用JavaScript。 JSValue: 代表一个JavaScript实体，一个JSValue可以表示很多JavaScript原始类型例如boolean, integers, doubles，甚至包括对象和函数。 JSContext: 代表JavaScript的运行环境，你需要用JSContext来执行JavaScript代码。所有的JSValue都是捆绑在一个JSContext上的. JSExport: 这是一个协议，可以用这个协议来将原生对象导出给JavaScript，这样原生对象的属性或方法就成为了JavaScript的属性或方法，非常神奇。 OC调用JS的方法采用stringByEvaluatingJavaScriptFromString写入JS代码，调用JS的方法采用系统框架的JSContext +evaluateScript调用JS代码 123456// 1.UIWebView执行JS代码[self.webView stringByEvaluatingJavaScriptFromString:@"showName('Willi')"];// 2.JavaScriptCore执行JSJSContext *context = [[JSContext alloc] init];NSString *jsCode = [NSString stringWithFormat:@"alert(\"我是OC里面的js方法\")"];[context evaluateScript:jsCode]; JS调用OC的方法 采用传统的方法，加载WebView的时候截取URL的方式 利用苹果系统框架的JSContext的block方式 或者 JSExport协议方式 123456789//注册printAandB方法 context[@"printAandB"] = ^(NSString *A ,NSString *B) &#123; NSLog(@"%@,%@",A,B); &#125;; //自定义协议，并且协议遵守&lt;JSExport&gt;协议@protocol WuKongJSExport &lt;JSExport&gt;JSExportAs(Invoke, - (void)invokeKey:(NSString *)key value:(NSString *)value);@end WKWebView与JavaScript的交互WKWebViewWKWebView是苹果在iOS 8中引入的新组件，目的是给出一个新的高性能的WebView解决方案，摆脱过去 UIWebView的老、旧、笨重，特别是内存占用量巨大的问题。 OC调用JS的方法 原生调用JavaScript的代码需要在页面加载完成之后，就是在 - webView:didFinishNavigation:代理方法里面 123[webView evaluateJavaScript:@"showAlert('奏是一个弹框')" completionHandler:^(id item, NSError * _Nullable error) &#123; // Block中处理是否通过了或者执行JS错误的代码 &#125;]; JS调用OC的方法 JavaScript的配置JavaScript调用Native的方法就需要前端和Native的小伙伴们配合了，需要前端的小伙伴在JS的方法中调用：window.webkit.messageHandlers.NativeMethod.postMessage(&quot;就是一个消息啊&quot;); Native App的代码配置 123456789101112131415161718 // 创建配置 WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init]; // 创建UserContentController（提供JavaScript向webView发送消息的方法） WKUserContentController* userContent = [[WKUserContentController alloc] init]; // 添加消息处理，注意：self指代的对象需要遵守WKScriptMessageHandler协议，结束时需要移除[userContent addScriptMessageHandler:self name:@"NativeMethod"]; // 将UserConttentController设置到配置文件 config.userContentController = userContent; // 高端的自定义配置创建WKWebView WKWebView *webView = [[WKWebView alloc] initWithFrame:[UIScreen mainScreen].bounds configuration:config]; // 设置访问的URL NSURL *url = [NSURL URLWithString:@"http://www.jianshu.com"]; // 根据URL创建请求 NSURLRequest *request = [NSURLRequest requestWithURL:url]; // WKWebView加载请求 [webView loadRequest:request]; // 将WKWebView添加到视图 [self.view addSubview:webView]; 可以看到，添加消息处理的handler的name，就是JavaScript中调用时候的NativeMethod，这两个要保持一致。请把URL换成你自己的。配置当前ViewController为MessageHandler，需要服从WKScriptMessageHandler协议，如果出现警告⚠️，请检查是否服从了这个协议。注意！注意！注意：上面将当前ViewController设置为MessageHandler之后需要在当前ViewController销毁前将其移除，否则会造成内存泄漏。 1[webView.configuration.userContentController removeScriptMessageHandlerForName:@"NativeMethod"]; 现在万事俱备，只欠东风了。可以看到WKScriptMessageHandler的协议里面只有一个方法，就是：- userContentController:didReceiveScriptMessage: 相信聪明的你已经猜到了。是的，就是在这个代理方法里面操作：如果JavaScript执行已经写好的：window.webkit.messageHandlers.NativeMethod.postMessage(“就是一个消息啊”);这行代码，这个代理方法就会走，并且会有个WKScriptMessage的对象，这个WKScriptMessage对象有个name属性，拿到之后你会发现，就是我们注册的NativeMethod这个字符串，这时候你就可以手动调用Native的方法了。如果有多个方法需要调用的话怎么办，看到JavaScript中postMessage()方法有一个参数了没有，可以根据这里的参数来区分调用原生App的哪个方法。 123456789- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123; // 判断是否是调用原生的 if ([@"NativeMethod" isEqualToString:message.name]) &#123; // 判断message的内容，然后做相应的操作 if ([@"close" isEqualToString:message.body]) &#123; &#125; &#125; &#125; 网页支持滑动返回 WKWebView比UIWebView有很多优势，在WKWebView中通过设置一个属性 allowsBackForwardNavigationGestures 就可以实现滑动返回，而UIWebView需要写很多代码来达到滑动返回效果。 项目最低支持iOS7，所以只能使用UIKit中的UIWebView，而新的WKWebView是支持iOS8+ WKWebView的内存开销要比UIWebView小很多 拥有高达60FPS滚动刷新率及内置手势 支持了更多的HTML5特性 html页面和WKWebView交互更方便 Safari相同的JavaScript引擎 提供常用的属性，如加载网页进度的属性estimatedProgress 实现思路：在UIWebView的Delegate的shouldStart代理方法中，把当前页面截一张图，把这张截图和对应的Url保存到一个数组中，在WebView上加一个UIPanGestureRecognizer拖拽手势，在手势代理方法中监听状态的变化，当手指滑动时，会把当前的截图和上一页截图，根据手势的移动的位置，做随手指移动的动画。然后重新请求上一个网页测试过程中发现，有时滑动好使有时不好使，最后了解到这个Pan手势和UIScrollview的Pan手势会冲突 [webpageView.scrollView.panGestureRecognizer requireGestureRecognizerToFail:_swipePanGesture]; 设置先识别滑动返回,在识别滚动的手势，偶尔会造成某些网站网页，不能滚动。 设置手势代理方法 - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer 返回YES,允许手势能同时识别。完美解决手势冲突 欢迎指正😝 资料WKWebView使用WKWeb​View(AFN作者)自己动手打造基于 WKWebView 的混合开发框架收藏一下]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wireshark抓包]]></title>
    <url>%2F2017%2F04%2F23%2FWireshark%E6%8A%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[介绍网络抓包是个基础技能，对于网络协议的掌握有一定的要求。iOS上实现网络抓包可以用Charles（针对http和https），tcpdump（快速分析网络包），和Wireshare。和tcpdump相比，Wireshark提供丰富的GUI交互，而且能分析所有的网络协议。 首先安装软件 官网下载，目前最新版本v2.2.7 打开主界面Wireshark在第一个界面就把当前系统所包含的网卡列出来了，直接点击任何一项就可以开始监听通过该网卡的所有网络流量。 RVI接口创建和管理当我们把iPhone通过usb连接macbook时，Wireshark并不能直接监听通过iPhone的网络流量，需要通过一个系统程序在我们的Mac系统上，建立一个映射到iPhone的虚拟网卡 通过数据线连接好iOS设备，拿到设备的UDID（Xcode或iTunes都行） terminal输入命令，格式是rvictl -s 设备UDID 执行命令之后Wireshark能立即识别新增加的rvi0网卡，也就是上图中高亮的部分，双击rvi0这一项，Wireshare即进入如下界面开始监听iPhone设备上的所有流量。 Android手机，可以下载个PacketCaptrue软件，用于抓包 如果出现下图错误，请用在终端用 sudo wireshark 命令启动 网络包结构经典的TCP/IP五层结构: 应用层 传输层 网络层 数据链路层 物理层 应用层是最内层的payload，除了应用层这一层之外，其他层都是用自己这一层的协议header+所包含那一层的payload。可以用如下公式表示：TCP Layer = TCP Header + Application PayloadIP Layer = IP Header + TCP Payload… 使用Filter过滤包使用Wireshark和使用Charles最大的区别在于，Charles只捕获HTTP流量，而Wireshark捕捉的是经过目标网卡所有的流量，流量包可以在几秒内膨胀到难以阅读的数量，所以此时我们需要使用Filter来做包的过滤，Filter规则定的越细，剔除掉的干扰信息就越多，分析起来就越快。 Wireshark的Filter分为两种，一种为Capture Filter，另一种是Display Filter。 Capture Filter出现在初始界面，在网卡列表的上方有个输入框，允许我们输入capture filter，一旦输入了特定的capture规则，Wireshark就只捕获符合该规则的流量包了。 Display Filter出现在流量监控界面，在工具栏的下方有个输入框，允许我们输入display filter，display filter只是从界面上过滤掉不符合规则的包，Wireshark实际上还是监听了这些包，一旦去掉display filter，所有的包又会出现在同一界面。 语法规则可以查看Wireshark官方文档 流量跟踪Wireshark默认情况下将不同网络连接的流量都混在一起展示，即使给不同协议的包上色之后，要单独查看某个特定连接的流量依然不怎么方便，我们可以通过Wireshark提供的两种方式来实现这个目标。 Follow Stream当我们选中某个包之后，右键弹出的菜单里，有个选项允许我们将当前包所属于的完整流量单独列出来，如 Flow GraphFlow Graph可以通过菜单Statistics-&gt;Flow Graph来生成，这样我们可以得到另一种形式的流量呈现 和Follow Stream不同的是我们获取到的是完整的流量，iPhone手机IP地址发出的流向多个服务器的网络流量，包括DNS解析和SSL安全握手等。当然我们也可以在上图中下方的操作区域做进一步的过滤，可以使用Display Filter做进一步的流量定位。]]></content>
      <tags>
        <tag>Wireshark</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift闭包]]></title>
    <url>%2F2017%2F03%2F05%2FSwift%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包概念闭包是可以在你的代码中被传递和引用的功能性独立模块。Swift 中的闭包和 C 以及 Objective-C 中的 blocks 很像，还有其他语言中的匿名函数也类似。在Swift中，提供三类闭包： 全局函数是一个有名字但不会捕获任何值的闭包。 嵌套（内嵌）函数是一个有名字并可以捕获到其封闭函数域内的值的闭包。 闭包表达式是一个利用轻量级语法所写的，可以捕获其上下文中变量或常量值的匿名闭包。 闭包表达式闭包表达式语法可以使用常量、变量和inout类型作为参数，不提供默认值。 也可以在参数列表的最后使用可变参数。 元组也可以作为参数和返回值。 闭包表达式语法的一般形式： 123&#123; (parameters) -&gt; (return type) in statements &#125; 关键字 in 来区分闭包的头和闭包函数体。 Swift 的标准库提供了一个叫做 sorted(by:) 的方法，会根据你提供的排序闭包将已知类型的数组的值进行排序。使用sorted方法对闭包简化例子： 1234567891011let names = ["Chris","Ewa","Barry","Daniella”]`// 普通函数func backward(_ s1: String, _ s2: String) -&gt; Bool &#123; return s1 &gt; s2&#125;var reversedNames = names.sorted(by: backward)// 使用闭包表达式reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2&#125;) 类型推断（因排序闭包为实际参数来传递给函数，故 Swift 能推断它的形式参数类型和返回类型。） 1reversedNames = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125; ) 从单表达式闭包隐式返回，return 关键字能够被省略reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )简写的实际参数名reversedNames = names.sorted(by: { $0 &gt; $1 } )还有一种更加简化的形式，直接使用操作符&gt;,可以写出这样的前提是闭包定义刚好和操作符的定义吻合。reversedNames = names.sorted(by: &gt;) 逃逸和非逃逸闭包Swift 的闭包分为 逃逸 与 非逃逸 两种。一个接受逃逸闭包作为参数的函数，逃逸闭包（可能）会在函数返回之后才被调用————也就是说，闭包逃离了函数的作用域。 逃逸闭包通常与异步控制流相关联，如下例所示： 一个函数开启了一个后台任务后立即返回，然后通过一个完成回调（completion handler）报告后台任务的结果。 一个视图类把『按钮点击事件执行的操作』封装成一个闭包，并存储为自身的属性。每次用户点击按钮时，都会调用该闭包。闭包会逃离属性的设置器（setter）。 你使用 DispatchQueue.async 在派发队列（dispatch queue）上安排了一个异步执行的任务。这个闭包任务的生命周期会比 async 的作用域活得更长久。与之对应的 DispatchQueue.sync，它会一直等到任务闭包执行完毕后才返回——闭包永远不会逃逸。map 以及标准库中其他的序列和数组的算法也是非逃逸的。 为什么区分闭包的逃逸性和非逃逸性如此重要简单来说，是为了管理内存。一个闭包会强引用它捕获的所有对象————如果你在闭包中访问了当前对象中的任意属性或实例方法，闭包会持有当前对象，因为这些方法和属性都隐性地携带了一个 self 参数。这种方式很容易导致循环引用，这解释了为什么编译器会要求你在闭包中显式地写出对 self 的引用。这迫使你考虑潜在的循环引用，并使用捕获列表手动处理。然而，使用非逃逸的闭包不会产生循环引用————编译器可以保证在函数返回时闭包会释放它捕获的所有对象。因此，编译器只要求在逃逸闭包中明确对 self 的强引用。显然，使用非逃逸闭包是一个更加愉悦的方案。 从 Swift 3.0 开始，非逃逸闭包变成了闭包参数的默认形式。如果你想允许一个闭包参数逃逸，需要给这个类型增加一个 @escaping 的标注。 解决闭包循环引用解决闭包的循环强引用Swift 提供了一种优雅的方法来解决这个问题，称之为闭包捕获列表（ closuer capture list ）捕获列表中的每一项都由 weak 或 unowned 关键字与类实例的引用（如 self ）成对组成 1234lazy var someClosure: (Int, String) -&gt; String = &#123; [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in // closure body goes here&#125; 参考闭包逃逸和非逃逸]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F01%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>